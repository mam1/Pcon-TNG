//
// automatically generated by spin2cpp v1.03 on Sun Nov 17 14:43:27 2013
// C:\Users\Dave\Desktop\test999\spin2cpp.exe --ccode test.spin 
//

#include <stdlib.h>
#include <propeller.h>
#include "fds.h"

#ifdef __GNUC__
#define INLINE__ static inline
#define Yield__() __asm__ volatile( "" ::: "memory" )
#define PostEffect__(X, Y) __extension__({ int32_t tmp__ = (X); (X) = (Y); tmp__; })
#else
#define INLINE__ static
static int32_t tmp__;
#define PostEffect__(X, Y) (tmp__ = (X), (X) = (Y), tmp__)
#define Yield__()
#define waitcnt(n) _waitcnt(n)
#define locknew() _locknew()
#define lockret(i) _lockret(i)
#define lockset(i) _lockset(i)
#define lockclr(i) _lockclr(i)
#define coginit(id, code, par) _coginit((unsigned)(par)>>2, (unsigned)(code)>>2, id)
#define cognew(code, par) coginit(0x8, (code), (par))
#define cogstop(i) _cogstop(i)
#endif

INLINE__ int32_t Rotl__(uint32_t a, uint32_t b) { return (a<<b) | (a>>(32-b)); }
INLINE__ int32_t Rotr__(uint32_t a, uint32_t b) { return (a>>b) | (a<<(32-b)); }
INLINE__ int32_t Lookup__(int32_t x, int32_t b, int32_t a[], int32_t n) { int32_t i = (x)-(b); return ((unsigned)i >= n) ? 0 : (a)[i]; }

static fdsSpin thisobj;
static uint8_t dat[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xa9, 0xbc, 0xa0, 0x10, 0xa8, 0xfc, 0x80, 
  0x54, 0xaa, 0xbc, 0x08, 0x01, 0xb2, 0xfc, 0xa0, 0x55, 0xb2, 0xbc, 0x2c, 0x04, 0xa8, 0xfc, 0x80, 
  0x54, 0xaa, 0xbc, 0x08, 0x01, 0xbe, 0xfc, 0xa0, 0x55, 0xbe, 0xbc, 0x2c, 0x04, 0xa8, 0xfc, 0x80, 
  0x54, 0xae, 0xbc, 0x08, 0x04, 0xa8, 0xfc, 0x80, 0x54, 0xb0, 0xbc, 0x08, 0x04, 0xa8, 0xfc, 0x80, 
  0x54, 0xb4, 0xbc, 0x08, 0x5a, 0xc0, 0xbc, 0xa0, 0x10, 0xc0, 0xfc, 0x80, 0x04, 0xae, 0x7c, 0x62, 
  0x02, 0xae, 0x7c, 0x61, 0x5f, 0xe8, 0x9b, 0x68, 0x5f, 0xec, 0xab, 0x68, 0x33, 0xc8, 0xfc, 0xa0, 
  0x64, 0xbc, 0xbc, 0x5c, 0x01, 0xae, 0x7c, 0x62, 0xf2, 0xb3, 0x3c, 0x61, 0x16, 0x00, 0x64, 0x5c, 
  0x09, 0xb8, 0xfc, 0xa0, 0x58, 0xba, 0xbc, 0xa0, 0x01, 0xba, 0xfc, 0x28, 0xf1, 0xbb, 0xbc, 0x80, 
  0x58, 0xba, 0xbc, 0x80, 0x64, 0xbc, 0xbc, 0x5c, 0x5d, 0xa8, 0xbc, 0xa0, 0xf1, 0xa9, 0xbc, 0x84, 
  0x00, 0xa8, 0x7c, 0xc1, 0x1f, 0x00, 0x4c, 0x5c, 0xf2, 0xb3, 0x3c, 0x61, 0x01, 0xb6, 0xfc, 0x30, 
  0x1e, 0xb8, 0xfc, 0xe4, 0x17, 0xb6, 0xfc, 0x28, 0xff, 0xb6, 0xfc, 0x60, 0x01, 0xae, 0x7c, 0x62, 
  0xff, 0xb6, 0xd4, 0x6c, 0xf0, 0xab, 0xbc, 0x08, 0x5a, 0xaa, 0xbc, 0x80, 0x55, 0xb6, 0x3c, 0x00, 
  0x5a, 0xaa, 0xbc, 0x84, 0x01, 0xaa, 0xfc, 0x80, 0x0f, 0xaa, 0xfc, 0x60, 0xf0, 0xab, 0x3c, 0x08, 
  0x16, 0x00, 0x7c, 0x5c, 0x5e, 0xc8, 0xbc, 0x5c, 0xf0, 0xa9, 0xbc, 0xa0, 0x08, 0xa8, 0xfc, 0x80, 
  0x54, 0xaa, 0xbc, 0x08, 0x04, 0xa8, 0xfc, 0x80, 0x54, 0xac, 0xbc, 0x08, 0x56, 0xaa, 0x3c, 0x86, 
  0x33, 0x00, 0x68, 0x5c, 0x60, 0xac, 0xbc, 0x80, 0x56, 0xc2, 0xbc, 0x00, 0x60, 0xac, 0xbc, 0x84, 
  0x01, 0xac, 0xfc, 0x80, 0x0f, 0xac, 0xfc, 0x60, 0x54, 0xac, 0x3c, 0x08, 0x00, 0xc3, 0xfc, 0x68, 
  0x02, 0xc2, 0xfc, 0x2c, 0x01, 0xc2, 0xfc, 0x68, 0x0b, 0xc4, 0xfc, 0xa0, 0xf1, 0xc7, 0xbc, 0xa0, 
  0x04, 0xae, 0x7c, 0x62, 0x02, 0xae, 0x7c, 0x61, 0x01, 0xc2, 0xe0, 0x6c, 0x01, 0xc2, 0xfc, 0x29, 
  0x5f, 0xe8, 0xab, 0x70, 0x5f, 0xec, 0x97, 0x74, 0x58, 0xc6, 0xbc, 0x80, 0x5e, 0xc8, 0xbc, 0x5c, 
  0x63, 0xa8, 0xbc, 0xa0, 0xf1, 0xa9, 0xbc, 0x84, 0x00, 0xa8, 0x7c, 0xc1, 0x4d, 0x00, 0x4c, 0x5c, 
  0x46, 0xc4, 0xfc, 0xe4, 0x33, 0x00, 0x7c, 0x5c, 
};
int32_t fdsSpin_Start(int32_t Rxpin, int32_t Txpin, int32_t Mode, int32_t Baudrate)
{
  int32_t _parm__0000[4];
  int32_t Okay = 0;
  _parm__0000[0] = Rxpin;
  _parm__0000[1] = Txpin;
  _parm__0000[2] = Mode;
  _parm__0000[3] = Baudrate;
  fdsSpin_Stop();
  { int32_t _fill__0001; int32_t *_ptr__0003 = (int32_t *)&(*(int32_t *)&dat[4]); int32_t _val__0002 = 0; for (_fill__0001 = 4; _fill__0001 > 0; --_fill__0001) {  *_ptr__0003++ = _val__0002; } };
  memmove( (void *)&(*(int32_t *)&dat[20]), (void *)&_parm__0000[0], 4*(3));
  ((int32_t *)&dat[32])[0] = (CLKFREQ / _parm__0000[3]);
  ((int32_t *)&dat[36])[0] = (int32_t)(&(*(uint8_t *)&dat[40]));
  Okay = (((int32_t *)&dat[0])[0] = (cognew((int32_t)(&(*(int32_t *)&dat[72])), (int32_t)(&(*(int32_t *)&dat[4]))) + 1));
  return Okay;
}

int32_t fdsSpin_Stop(void)
{
  if ((*(int32_t *)&dat[0])) {
    cogstop((PostEffect__((*(int32_t *)&dat[0]), 0) - 1));
  }
  { int32_t _fill__0004; int32_t *_ptr__0006 = (int32_t *)&(*(int32_t *)&dat[4]); int32_t _val__0005 = 0; for (_fill__0004 = 9; _fill__0004 > 0; --_fill__0004) {  *_ptr__0006++ = _val__0005; } };
  return 0;
}

int32_t fdsSpin_Rxflush(void)
{
  while (fdsSpin_Rxcheck() >= 0) {
    Yield__();
  }
  return 0;
}

int32_t fdsSpin_Rxcheck(void)
{
  int32_t Rxbyte = 0;
  (Rxbyte--);
  if (((int32_t *)&dat[8])[0] != ((int32_t *)&dat[4])[0]) {
    Rxbyte = ((uint8_t *)&dat[40])[(*(int32_t *)&dat[8])];
    ((int32_t *)&dat[8])[0] = (((*(int32_t *)&dat[8]) + 1) & 0xf);
  }
  return Rxbyte;
}

int32_t fdsSpin_Rxtime(int32_t Ms)
{
  int32_t	T;
  int32_t Rxbyte = 0;
  T = CNT;
  while (!(((Rxbyte = fdsSpin_Rxcheck()) >= 0) || (((CNT - T) / (CLKFREQ / 1000)) > Ms))) {
    Yield__();
  }
  return Rxbyte;
}

int32_t fdsSpin_Rx(void)
{
  int32_t Rxbyte = 0;
  while ((Rxbyte = fdsSpin_Rxcheck()) < 0) {
    Yield__();
  }
  return Rxbyte;
}

int32_t fdsSpin_Tx(int32_t Txbyte)
{
  while (!(((int32_t *)&dat[16])[0] != (((*(int32_t *)&dat[12]) + 1) & 0xf))) {
    Yield__();
  }
  ((uint8_t *)&dat[56])[(*(int32_t *)&dat[12])] = Txbyte;
  ((int32_t *)&dat[12])[0] = (((*(int32_t *)&dat[12]) + 1) & 0xf);
  if (((int32_t *)&dat[28])[0] & 0x8) {
    fdsSpin_Rx();
  }
  return 0;
}

int32_t fdsSpin_Str(int32_t Stringptr)
{
  {
    int32_t _idx__0007;
    int32_t _limit__0008 = strlen((char *) Stringptr);
    for(_idx__0007 = 1; _idx__0007 <= _limit__0008; (_idx__0007 = (_idx__0007 + 1))) {
      fdsSpin_Tx(((uint8_t *)(Stringptr++))[0]);
    }
  }
  return 0;
}

int32_t fdsSpin_Dec(int32_t Value)
{
  int32_t	I, X;
  int32_t result = 0;
  X = -(Value == (int32_t)0x80000000U);
  if (Value < 0) {
    Value = (abs((Value + X)));
    fdsSpin_Tx('-');
  }
  I = 1000000000;
  {
    int32_t _idx__0009;
    for(_idx__0009 = 1; _idx__0009 <= 10; (_idx__0009 = (_idx__0009 + 1))) {
      if (Value >= I) {
        fdsSpin_Tx((((Value / I) + '0') + (X * -(I == 1))));
        Value = (Value % I);
        result = -1;
      } else {
        if ((result) || (I == 1)) {
          fdsSpin_Tx('0');
        }
      }
      I = (I / 10);
    }
  }
  return result;
}

int32_t fdsSpin_Hex(int32_t Value, int32_t Digits)
{
  static int32_t look__0010[] = {48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, };

  Value = (Value << ((8 - Digits) << 2));
  {
    int32_t _idx__0011;
    int32_t _limit__0012 = Digits;
    for(_idx__0011 = 1; _idx__0011 <= _limit__0012; (_idx__0011 = (_idx__0011 + 1))) {
      fdsSpin_Tx(Lookup__(((Value = (Rotl__(Value, 4))) & 0xf), 0, look__0010, 16));
    }
  }
  return 0;
}

int32_t fdsSpin_Bin(int32_t Value, int32_t Digits)
{
  Value = (Value << (32 - Digits));
  {
    int32_t _idx__0013;
    int32_t _limit__0014 = Digits;
    for(_idx__0013 = 1; _idx__0013 <= _limit__0014; (_idx__0013 = (_idx__0013 + 1))) {
      fdsSpin_Tx((((Value = (Rotl__(Value, 1))) & 0x1) + '0'));
    }
  }
  return 0;
}

